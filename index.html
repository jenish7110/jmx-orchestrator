<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JMX Orchestrator Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif; }
        .tab-active { border-bottom: 2px solid #000; font-weight: 600; }
        .status-enabled { background-color: #dcfce7; color: #166534; border: 1px solid #bbf7d0; }
        .status-disabled { background-color: #fee2e2; color: #991b1b; border: 1px solid #fecaca; }
        .metric-card { padding: 1rem; border-radius: 0.5rem; border: 1px solid #e5e7eb; background-color: #f9fafb; }
        .input-field { border: 1px solid #d1d5db; border-radius: 0.375rem; padding: 0.5rem 0.75rem; }
        .input-field:focus { outline: none; border-color: #000; box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1); }
        .warning-box { background-color: #fef3c7; border-left: 4px solid #f59e0b; padding: 1rem; border-radius: 0.5rem; }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <header class="bg-white border-b border-gray-200 sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 py-4">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-2xl font-bold text-gray-900">JMX Orchestrator Pro</h1>
                    <p class="text-sm text-gray-600">Unified JMeter 5.6.3 Controller with TPS Correlation</p>
                </div>
                <div class="flex items-center gap-4">
                    <div id="modeIndicator" class="hidden px-4 py-2 bg-gray-900 text-white rounded-lg text-sm font-semibold">
                        <span class="text-gray-400 mr-2">Mode:</span>
                        <span id="currentMode">Iteration</span>
                    </div>
                    <span class="text-xs text-gray-500">v3.1.0</span>
                    <div class="w-2 h-2 bg-green-500 rounded-full"></div>
                </div>
            </div>
        </div>
    </header>

    <main class="max-w-7xl mx-auto px-4 py-6">
        <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-6">
            <div class="flex items-center justify-between gap-4">
                <div class="flex-1">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Upload JMX File</label>
                    <input type="file" id="fileInput" accept=".jmx" 
                           class="block w-full text-sm text-gray-900 border border-gray-300 rounded-lg cursor-pointer bg-gray-50 focus:outline-none file:mr-4 file:py-2 file:px-4 file:rounded-l-lg file:border-0 file:bg-black file:text-white hover:file:bg-gray-800">
                </div>
                <button id="downloadBtn" disabled onclick="downloadJMX()" 
                        class="px-6 py-2 bg-black text-white rounded-lg hover:bg-gray-800 transition-colors disabled:bg-gray-300 disabled:cursor-not-allowed">
                    üíæ Download
                </button>
            </div>
        </div>

        <div id="uploadPrompt" class="bg-white rounded-lg shadow-sm border border-gray-200 p-12 text-center">
            <svg class="w-16 h-16 mx-auto text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
            </svg>
            <h3 class="text-xl font-semibold text-gray-700 mb-2">Upload JMX File to Begin</h3>
            <p class="text-gray-500">Select a JMeter test plan to view and edit thread groups</p>
        </div>

        <div id="mainContent" style="display: none;">
            <div class="mb-6 border-b border-gray-200">
                <nav class="flex gap-8">
                    <button onclick="switchTab('master')" id="tab-master" class="pb-3 px-1 text-sm font-medium text-gray-700 hover:text-gray-900 tab-active">Master Control</button>
                    <button onclick="switchTab('tps-calculator')" id="tab-tps-calculator" class="pb-3 px-1 text-sm font-medium text-gray-700 hover:text-gray-900">TPS Calculator</button>
                    <button onclick="switchTab('execution')" id="tab-execution" class="pb-3 px-1 text-sm font-medium text-gray-700 hover:text-gray-900">Execution Modes</button>
                    <button onclick="switchTab('threadgroups')" id="tab-threadgroups" class="pb-3 px-1 text-sm font-medium text-gray-700 hover:text-gray-900">Thread Groups</button>
                    <button onclick="switchTab('variables')" id="tab-variables" class="pb-3 px-1 text-sm font-medium text-gray-700 hover:text-gray-900">Variables</button>
                </nav>
            </div>

            <div id="content-master" class="tab-content">
                <div class="bg-white rounded-lg shadow-sm border-2 border-black p-6 mb-6">
                    <h3 class="text-lg font-bold text-gray-900 mb-2">üéØ Master Scenario Scaling</h3>
                    <p class="text-sm text-gray-600 mb-4">Scale entire scenario - affects ALL thread groups and TPS</p>
                    <div class="flex items-center gap-4">
                        <div class="flex-1">
                            <label class="block text-sm font-medium text-gray-700 mb-2">Scale Percentage</label>
                            <input type="number" id="masterScale" value="100" min="1" max="1000" step="1" class="input-field w-32 text-center text-lg font-semibold">
                        </div>
                        <button onclick="applyMasterScale()" class="px-6 py-3 bg-black text-white font-semibold rounded-lg hover:bg-gray-800 transition-colors mt-6">Apply to All</button>
                    </div>
                    <div class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-2 text-xs text-gray-600">
                        <div class="p-2 bg-gray-100 rounded">150% ‚Üí √ó1.5</div>
                        <div class="p-2 bg-gray-100 rounded">200% ‚Üí √ó2</div>
                        <div class="p-2 bg-gray-100 rounded">50% ‚Üí √ó0.5</div>
                        <div class="p-2 bg-gray-100 rounded">75% ‚Üí √ó0.75</div>
                    </div>
                </div>

                <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-6">
                    <h3 class="text-lg font-bold text-gray-900 mb-4">üñ•Ô∏è Slave/Node Scaling</h3>
                    <div class="flex items-center gap-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Number of Slaves</label>
                            <input type="number" id="slaves" value="1" min="1" class="input-field w-32 text-center" onchange="renderTable()">
                        </div>
                        <div class="text-sm text-gray-600">Each thread group multiplied by this number</div>
                    </div>
                </div>

                <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
                    <h3 class="text-lg font-bold text-gray-900 mb-4">üìä Performance Summary</h3>
                    <div class="grid grid-cols-2 md:grid-cols-5 gap-4">
                        <div class="metric-card">
                            <div class="text-sm text-gray-600 mb-1">Active Groups</div>
                            <div class="text-2xl font-bold" id="activeGroups">0</div>
                        </div>
                        <div class="metric-card">
                            <div class="text-sm text-gray-600 mb-1">Original Users</div>
                            <div class="text-2xl font-bold" id="originalUsers">0</div>
                        </div>
                        <div class="metric-card">
                            <div class="text-sm text-gray-600 mb-1">Scaled Users</div>
                            <div class="text-2xl font-bold text-green-600" id="scaledUsers">0</div>
                        </div>
                        <div class="metric-card">
                            <div class="text-sm text-gray-600 mb-1">Original TPS</div>
                            <div class="text-2xl font-bold" id="originalTPS">N/A</div>
                        </div>
                        <div class="metric-card">
                            <div class="text-sm text-gray-600 mb-1">Scaled TPS</div>
                            <div class="text-2xl font-bold text-green-600" id="scaledTPS">N/A</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="content-tps-calculator" class="tab-content" style="display: none;">
                <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-6">
                    <h3 class="text-lg font-bold text-gray-900 mb-4">üßÆ TPS-to-Users Calculator</h3>
                    <p class="text-sm text-gray-600 mb-4">Calculate required users to achieve target TPS</p>
                    <div class="grid md:grid-cols-2 gap-6 mb-6">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Target Total TPS</label>
                            <input type="number" id="targetTPS" min="0.01" step="0.01" placeholder="Enter target TPS" class="input-field w-full">
                            <p class="text-xs text-gray-500 mt-1">Desired transactions per second</p>
                        </div>
                        <div>
                            <button onclick="calculateUsersFromTPS()" class="w-full px-6 py-3 bg-black text-white font-semibold rounded-lg hover:bg-gray-800 transition-colors mt-6">Calculate</button>
                        </div>
                    </div>
                    <div id="tpsCalculationResult" style="display: none;" class="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                        <h4 class="font-semibold text-gray-900 mb-3">üìä Results</h4>
                        <div id="tpsResultContent" class="space-y-2 text-sm"></div>
                    </div>
                    <div class="warning-box mt-6">
                        <h4 class="font-semibold text-gray-900 mb-2">‚ö†Ô∏è Best Practices</h4>
                        <ul class="text-sm text-gray-700 space-y-1 list-disc list-inside">
                            <li>TPS per user = Total TPS / Total Users</li>
                            <li>Minimum 1 user per thread group</li>
                            <li>System rounds up to ensure targets</li>
                        </ul>
                    </div>
                </div>

                <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
                    <h3 class="text-lg font-bold text-gray-900 mb-4">üéØ Individual TPS Adjustment</h3>
                    <div id="individualTPSControls"></div>
                </div>
            </div>

            <div id="content-execution" class="tab-content" style="display: none;">
                <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-6">
                    <h3 class="text-lg font-bold text-gray-900 mb-4">‚öôÔ∏è Execution Mode</h3>
                    <select id="executionMode" onchange="changeExecutionMode()" class="input-field w-full">
                        <option value="iteration">Iteration-Based (Finite loops)</option>
                        <option value="duration">Duration-Based (Infinite loops)</option>
                        <option value="sanity">Sanity Mode (1 user, fixed ramp-up)</option>
                    </select>
                    <div class="mt-4 p-4 bg-gray-50 rounded-lg">
                        <p class="text-sm text-gray-700" id="modeDescription">Tests run for specific iterations per user</p>
                    </div>
                </div>

                <div id="sanityConfig" style="display: none;" class="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-6">
                    <h3 class="text-lg font-bold text-gray-900 mb-4">üîç Sanity Mode Config</h3>
                    <div class="grid md:grid-cols-3 gap-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Users</label>
                            <input type="number" id="sanityUsers" value="1" min="1" class="input-field w-full text-center" disabled>
                            <p class="text-xs text-gray-500 mt-1">Fixed at 1</p>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Ramp-up (sec)</label>
                            <input type="number" id="sanityRampup" value="1" min="1" class="input-field w-full text-center">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Iterations</label>
                            <input type="number" id="sanityIterations" value="5" min="1" class="input-field w-full text-center">
                        </div>
                    </div>
                    <div class="mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg text-sm text-yellow-800">
                        ‚ö†Ô∏è Disables PreciseThroughputTimer and sets fixed ramp-up values
                    </div>
                </div>

                <div id="durationControls" style="display: none;">
                    <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-6">
                        <h3 class="text-lg font-bold text-gray-900 mb-4">‚è±Ô∏è Duration Settings</h3>
                        <div class="grid md:grid-cols-2 gap-6">
                            <div>
                                <h4 class="font-semibold text-gray-900 mb-3">Ramp-up</h4>
                                <div class="flex items-center gap-2 mb-3">
                                    <input type="number" id="usersPerInterval" value="1" min="1" class="input-field w-20 text-center">
                                    <span class="text-sm">user(s) every</span>
                                    <input type="number" id="intervalSeconds" value="1" min="1" class="input-field w-20 text-center">
                                    <span class="text-sm">sec</span>
                                </div>
                                <div class="text-sm text-gray-600">
                                    <div>Total Users: <span class="font-semibold" id="totalUsersDisplay">0</span></div>
                                    <div>Est. ramp-up: <span class="font-semibold" id="estimatedRampup">0h 0m 0s</span></div>
                                </div>
                            </div>
                            <div>
                                <h4 class="font-semibold text-gray-900 mb-3">Duration</h4>
                                <div class="flex items-center gap-2 mb-3">
                                    <input type="number" id="durationHours" value="0" min="0" class="input-field w-16 text-center">
                                    <span class="text-sm">h</span>
                                    <input type="number" id="durationMinutes" value="0" min="0" max="59" class="input-field w-16 text-center">
                                    <span class="text-sm">m</span>
                                    <input type="number" id="durationSeconds" value="0" min="0" max="59" class="input-field w-16 text-center">
                                    <span class="text-sm">s</span>
                                </div>
                                <div class="text-sm text-gray-600">Total: <span class="font-semibold" id="totalDuration">0 sec</span></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
                    <h3 class="text-lg font-bold text-gray-900 mb-4">üîß Bulk Actions</h3>
                    <div class="flex items-center gap-3">
                        <button onclick="enableAllThreadGroups()" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700">‚úì Enable All</button>
                        <button onclick="disableAllThreadGroups()" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">‚úï Disable All</button>
                        <div class="ml-auto text-sm text-gray-600">
                            <span class="font-semibold text-green-600" id="enabledCount">0</span> enabled / 
                            <span class="font-semibold text-red-600" id="disabledCount">0</span> disabled
                        </div>
                    </div>
                </div>
            </div>

            <div id="content-threadgroups" class="tab-content" style="display: none;">
                <div class="bg-white rounded-lg shadow-sm border border-gray-200">
                    <div class="px-6 py-4 border-b border-gray-200">
                        <h3 class="text-lg font-bold text-gray-900">üìã Thread Groups</h3>
                    </div>
                    <div class="overflow-x-auto">
                        <table class="w-full">
                            <thead class="bg-gray-50 border-b border-gray-200">
                                <tr>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase">Status</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase">Name</th>
                                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-700 uppercase">Users</th>
                                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-700 uppercase">Scaled</th>
                                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-700 uppercase" id="loopHeader">Loops</th>
                                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-700 uppercase">TPS/User</th>
                                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-700 uppercase">Orig TPS</th>
                                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-700 uppercase">Scaled TPS</th>
                                </tr>
                            </thead>
                            <tbody id="threadGroupsTableBody" class="divide-y divide-gray-200"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div id="content-variables" class="tab-content" style="display: none;">
                <div class="grid md:grid-cols-2 gap-6">
                    <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
                        <h3 class="text-lg font-bold text-gray-900 mb-4">Ramp-up Time</h3>
                        <div class="text-3xl font-bold text-gray-900 mb-2" id="rampupValue">N/A</div>
                        <div class="text-sm text-gray-600" id="rampupHours">N/A</div>
                    </div>
                    <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
                        <h3 class="text-lg font-bold text-gray-900 mb-4">Steady State</h3>
                        <div class="text-3xl font-bold text-gray-900 mb-2" id="steadyStateValue">N/A</div>
                        <div class="text-sm text-gray-600" id="steadyStateHours">N/A</div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <div id="toast" class="fixed bottom-4 right-4 bg-black text-white px-6 py-3 rounded-lg shadow-lg transform transition-transform duration-300 translate-y-20 opacity-0" style="z-index: 1000;">
        <span id="toastMessage"></span>
    </div>

    <script>
        let jmxDocument = null;
        let threadGroupData = [];
        let globalVariables = { rampup: "N/A", steadyState: "N/A" };
        let executionMode = 'iteration';

        const executionModes = {
            iteration: { description: 'Tests run for specific iterations per user', loopType: 'finite' },
            duration: { description: 'Tests run for specific duration with infinite loops', loopType: 'infinite' },
            sanity: { description: 'Quick validation - 1 user, fixed ramp-up, configurable iterations', loopType: 'finite' }
        };

        function switchTab(tab) {
            document.querySelectorAll('.tab-content').forEach(el => el.style.display = 'none');
            document.querySelectorAll('[id^="tab-"]').forEach(el => el.classList.remove('tab-active'));
            document.getElementById(`content-${tab}`).style.display = 'block';
            document.getElementById(`tab-${tab}`).classList.add('tab-active');
            if (tab === 'tps-calculator') renderIndividualTPSControls();
        }

        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(event) {
                const parser = new DOMParser();
                jmxDocument = parser.parseFromString(event.target.result, "text/xml");
                if (jmxDocument.querySelector('parsererror')) {
                    showToast('Invalid XML format', 'error');
                    return;
                }
                extractGlobalVariables();
                extractThreadGroups();
                document.getElementById('uploadPrompt').style.display = 'none';
                document.getElementById('mainContent').style.display = 'block';
                document.getElementById('downloadBtn').disabled = false;
                renderTable();
                updateVariablesTab();
                showToast('JMX loaded successfully!', 'success');
            };
            reader.readAsText(file);
        });

        function extractGlobalVariables() {
            const argumentsList = jmxDocument.getElementsByTagName("Arguments");
            globalVariables = { rampup: "N/A", steadyState: "N/A" };
            for (let i = 0; i < argumentsList.length; i++) {
                const arg = argumentsList[i];
                if (arg.getAttribute("testname") === "rampupSteadyDuration") {
                    const elements = arg.getElementsByTagName("elementProp");
                    for (let j = 0; j < elements.length; j++) {
                        const nameNode = elements[j].getElementsByTagName("stringProp")[0];
                        const valueNode = elements[j].getElementsByTagName("stringProp")[1];
                        if (nameNode && valueNode) {
                            if (nameNode.textContent === "rampup") globalVariables.rampup = valueNode.textContent;
                            if (nameNode.textContent === "steadyState") globalVariables.steadyState = valueNode.textContent;
                        }
                    }
                }
            }
        }

        function extractThreadGroups() {
            const threadGroups = jmxDocument.getElementsByTagName("ThreadGroup");
            threadGroupData = [];
            for (let i = 0; i < threadGroups.length; i++) {
                const tg = threadGroups[i];
                const name = tg.getAttribute("testname");
                const enabled = tg.getAttribute("enabled") === "true" || tg.getAttribute("enabled") === null;
                let count = 1;
                const intProps = tg.getElementsByTagName("intProp");
                for (let j = 0; j < intProps.length; j++) {
                    if (intProps[j].getAttribute("name") === "ThreadGroup.num_threads") {
                        count = parseInt(intProps[j].textContent.trim(), 10);
                        break;
                    }
                }
                if (count === 1) {
                    const stringProps = tg.getElementsByTagName("stringProp");
                    for (let j = 0; j < stringProps.length; j++) {
                        if (stringProps[j].getAttribute("name") === "ThreadGroup.num_threads") {
                            count = parseInt(stringProps[j].textContent.trim(), 10) || 1;
                            break;
                        }
                    }
                }
                let loops = '1';
                const loopController = tg.querySelector('elementProp[name="ThreadGroup.main_controller"]');
                if (loopController) {
                    const loopsProps = loopController.getElementsByTagName('stringProp');
                    for (let j = 0; j < loopsProps.length; j++) {
                        if (loopsProps[j].getAttribute('name') === 'LoopController.loops') {
                            loops = loopsProps[j].textContent.trim();
                            break;
                        }
                    }
                }
                let throughput = 0;
                const tgHashTree = tg.nextElementSibling;
                if (tgHashTree && tgHashTree.tagName === "hashTree") {
                    throughput = findThroughputInHashTree(tgHashTree);
                }
                threadGroupData.push({ element: tg, name: name, count: count, originalCount: count, loops: loops, status: enabled, throughput: throughput, originalThroughput: throughput });
            }
        }

        function findThroughputInHashTree(hashTree) {
            let throughput = 0;
            for (let child of hashTree.children) {
                if (child.tagName === "PreciseThroughputTimer") {
                    const doubleProps = child.getElementsByTagName("doubleProp");
                    for (let dp of doubleProps) {
                        if (dp.getAttribute("name") === "throughput") {
                            const value = parseFloat(dp.textContent.trim());
                            if (!isNaN(value)) throughput += value;
                        } else {
                            const nameElement = dp.getElementsByTagName("name")[0];
                            const valueElement = dp.getElementsByTagName("value")[0];
                            if (nameElement && nameElement.textContent === "throughput" && valueElement) {
                                const value = parseFloat(valueElement.textContent.trim());
                                if (!isNaN(value)) throughput += value;
                            }
                        }
                    }
                }
                if (child.tagName === "hashTree") throughput += findThroughputInHashTree(child);
            }
            return throughput;
        }

        function calculateUsersFromTPS() {
            const targetTPS = parseFloat(document.getElementById('targetTPS').value);
            if (isNaN(targetTPS) || targetTPS <= 0) {
                showToast('Enter valid TPS > 0', 'error');
                return;
            }
            let totalCurrentUsers = 0, totalCurrentTPS = 0;
            threadGroupData.forEach(tg => {
                if (tg.status && tg.throughput > 0) {
                    totalCurrentUsers += tg.count;
                    totalCurrentTPS += tg.throughput;
                }
            });
            if (totalCurrentTPS === 0) {
                showToast('No active thread groups with TPS', 'error');
                return;
            }
            const currentTPSPerUser = totalCurrentTPS / totalCurrentUsers;
            const requiredUsers = Math.ceil(targetTPS / currentTPSPerUser);
            const scalingFactor = requiredUsers / totalCurrentUsers;
            let resultHTML = `<div class="space-y-3"><div class="grid grid-cols-2 gap-4">
                <div><div class="text-xs text-gray-600">Current TPS</div><div class="text-lg font-bold">${totalCurrentTPS.toFixed(2)} TPS</div></div>
                <div><div class="text-xs text-gray-600">Target TPS</div><div class="text-lg font-bold text-green-600">${targetTPS.toFixed(2)} TPS</div></div>
                <div><div class="text-xs text-gray-600">Current Users</div><div class="text-lg font-bold">${totalCurrentUsers}</div></div>
                <div><div class="text-xs text-gray-600">Required Users</div><div class="text-lg font-bold text-green-600">${requiredUsers}</div></div>
                <div><div class="text-xs text-gray-600">TPS per User</div><div class="text-lg font-bold">${currentTPSPerUser.toFixed(4)}</div></div>
                <div><div class="text-xs text-gray-600">Scaling Factor</div><div class="text-lg font-bold">${scalingFactor.toFixed(2)}x</div></div>
            </div><div class="pt-3 border-t border-gray-200"><div class="text-xs text-gray-600 mb-2">Per Thread Group:</div><div class="space-y-1 text-xs">`;
            threadGroupData.forEach(tg => {
                if (tg.status && tg.throughput > 0) {
                    const newUsers = Math.max(1, Math.ceil(tg.count * scalingFactor));
                    const newTPS = (tg.throughput * scalingFactor).toFixed(2);
                    resultHTML += `<div class="flex justify-between p-2 bg-gray-50 rounded"><span class="font-medium">${escapeHtml(tg.name)}</span><span>${tg.count} ‚Üí <strong>${newUsers}</strong> users | ${tg.throughput.toFixed(2)} ‚Üí <strong>${newTPS}</strong> TPS</span></div>`;
                }
            });
            resultHTML += `</div></div><button onclick="applyTPSCalculation(${scalingFactor})" class="w-full mt-4 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700">Apply Changes</button></div>`;
            document.getElementById('tpsResultContent').innerHTML = resultHTML;
            document.getElementById('tpsCalculationResult').style.display = 'block';
        }

        function applyTPSCalculation(scalingFactor) {
            threadGroupData.forEach(tg => {
                if (tg.status && tg.throughput > 0) {
                    const newUsers = Math.max(1, Math.ceil(tg.count * scalingFactor));
                    tg.count = newUsers;
                    tg.throughput = tg.throughput * scalingFactor;
                    updateThreadCountInXML(tg.element, newUsers);
                    const tgHashTree = tg.element.nextElementSibling;
                    if (tgHashTree && tgHashTree.tagName === "hashTree") {
                        updateThroughputInHashTree(tgHashTree, scalingFactor);
                    }
                }
            });
            renderTable();
            showToast('TPS scaling applied!', 'success');
            document.getElementById('tpsCalculationResult').style.display = 'none';
            document.getElementById('targetTPS').value = '';
        }

        function renderIndividualTPSControls() {
            const container = document.getElementById('individualTPSControls');
            let html = '<div class="space-y-4">';
            threadGroupData.forEach((tg, index) => {
                if (tg.status) {
                    const tpsPerUser = tg.count > 0 && tg.throughput > 0 ? (tg.throughput / tg.count).toFixed(4) : 'N/A';
                    html += `<div class="border border-gray-200 rounded-lg p-4">
                        <div class="flex items-center justify-between mb-3">
                            <h4 class="font-semibold text-gray-900">${escapeHtml(tg.name)}</h4>
                            <span class="text-xs text-gray-500">TPS/User: ${tpsPerUser}</span>
                        </div>
                        <div class="grid grid-cols-3 gap-4">
                            <div><label class="block text-xs text-gray-600 mb-1">Current Users</label><div class="text-lg font-bold">${tg.count}</div></div>
                            <div><label class="block text-xs text-gray-600 mb-1">Current TPS</label><div class="text-lg font-bold">${tg.throughput > 0 ? tg.throughput.toFixed(2) : 'N/A'}</div></div>
                            <div><label class="block text-xs text-gray-600 mb-1">Target TPS</label><input type="number" id="tps-${index}" min="0.01" step="0.01" class="input-field w-full text-center" placeholder="TPS"></div>
                        </div>
                        <button onclick="adjustIndividualTPS(${index})" class="mt-3 w-full px-4 py-2 bg-gray-900 text-white text-sm rounded-lg hover:bg-gray-800">Calculate & Apply</button>
                    </div>`;
                }
            });
            html += '</div>';
            container.innerHTML = html;
        }

        function adjustIndividualTPS(index) {
            const targetTPS = parseFloat(document.getElementById(`tps-${index}`).value);
            const tg = threadGroupData[index];
            if (isNaN(targetTPS) || targetTPS <= 0) {
                showToast('Enter valid TPS', 'error');
                return;
            }
            if (tg.throughput === 0) {
                showToast('No TPS configured', 'error');
                return;
            }
            const currentTPSPerUser = tg.throughput / tg.count;
            const requiredUsers = Math.max(1, Math.ceil(targetTPS / currentTPSPerUser));
            const scalingFactor = requiredUsers / tg.count;
            const newTPS = tg.throughput * scalingFactor;
            if (confirm(`Change ${escapeHtml(tg.name)}:\n\nUsers: ${tg.count} ‚Üí ${requiredUsers}\nTPS: ${tg.throughput.toFixed(2)} ‚Üí ${newTPS.toFixed(2)}\n\nApply?`)) {
                tg.count = requiredUsers;
                tg.throughput = newTPS;
                updateThreadCountInXML(tg.element, requiredUsers);
                const tgHashTree = tg.element.nextElementSibling;
                if (tgHashTree && tgHashTree.tagName === "hashTree") {
                    updateThroughputInHashTree(tgHashTree, scalingFactor);
                }
                renderTable();
                renderIndividualTPSControls();
                showToast(`Updated ${tg.name}!`, 'success');
            }
        }

        function renderTable() {
            const slaves = parseInt(document.getElementById("slaves").value, 10) || 1;
            let totalOriginalUsers = 0, totalScaledUsers = 0, totalOriginalTPS = 0, totalScaledTPS = 0, enabledCount = 0, disabledCount = 0;
            threadGroupData.forEach(tg => {
                let count = tg.count, loops = tg.loops;
                if (executionMode === 'sanity') {
                    count = 1;
                    loops = document.getElementById('sanityIterations').value || '5';
                } else if (executionMode === 'duration') {
                    loops = '-1';
                }
                const scaledCount = count * slaves;
                if (tg.status) {
                    totalOriginalUsers += count;
                    totalScaledUsers += scaledCount;
                    if (tg.throughput > 0) {
                        totalOriginalTPS += tg.throughput;
                        totalScaledTPS += tg.throughput * slaves;
                    }
                    enabledCount++;
                } else {
                    disabledCount++;
                }
            });
            document.getElementById('activeGroups').textContent = `${enabledCount} / ${threadGroupData.length}`;
            document.getElementById('originalUsers').textContent = totalOriginalUsers;
            document.getElementById('scaledUsers').textContent = totalScaledUsers;
            document.getElementById('originalTPS').textContent = totalOriginalTPS > 0 ? totalOriginalTPS.toFixed(2) : 'N/A';
            document.getElementById('scaledTPS').textContent = totalScaledTPS > 0 ? totalScaledTPS.toFixed(2) : 'N/A';
            document.getElementById('enabledCount').textContent = enabledCount;
            document.getElementById('disabledCount').textContent = disabledCount;
            const tableBody = document.getElementById('threadGroupsTableBody');
            tableBody.innerHTML = '';
            threadGroupData.forEach((tg, index) => {
                let count = tg.count, loops = tg.loops;
                if (executionMode === 'sanity') {
                    count = 1;
                    loops = document.getElementById('sanityIterations').value || '5';
                } else if (executionMode === 'duration') {
                    loops = '-1';
                }
                const scaledCount = count * slaves;
                const scaledTPS = tg.throughput > 0 ? (tg.throughput * slaves).toFixed(2) : "N/A";
                const originalTPS = tg.throughput > 0 ? tg.throughput.toFixed(2) : "N/A";
                const tpsPerUser = tg.count > 0 && tg.throughput > 0 ? (tg.throughput / tg.count).toFixed(4) : "N/A";
                const statusClass = tg.status ? 'status-enabled' : 'status-disabled';
                const statusText = tg.status ? 'Enabled' : 'Disabled';
                const rowClass = tg.status ? '' : 'bg-gray-50';
                let loopDisplay = executionMode === 'duration' ? '<span class="text-gray-500 italic">Infinite</span>' : `<input type="number" min="-1" value="${loops}" onchange="updateLoopCount(${index}, this.value)" class="input-field w-20 text-center text-sm" ${executionMode === 'sanity' ? 'disabled' : ''}>`;
                const row = document.createElement('tr');
                row.className = `${rowClass} hover:bg-gray-100 transition-colors`;
                row.innerHTML = `
                    <td class="px-4 py-3"><span onclick="toggleStatus(${index})" class="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium ${statusClass} cursor-pointer hover:opacity-80">${statusText}</span></td>
                    <td class="px-4 py-3 text-sm font-medium text-gray-900">${escapeHtml(tg.name)}</td>
                    <td class="px-4 py-3 text-center"><input type="number" min="1" value="${count}" onchange="updateThreadCount(${index}, this.value)" class="input-field w-20 text-center text-sm" ${executionMode === 'sanity' ? 'disabled' : ''}></td>
                    <td class="px-4 py-3 text-center font-semibold text-gray-900">${scaledCount}</td>
                    <td class="px-4 py-3 text-center">${loopDisplay}</td>
                    <td class="px-4 py-3 text-center text-xs text-gray-600">${tpsPerUser}</td>
                    <td class="px-4 py-3 text-center text-gray-700">${originalTPS}</td>
                    <td class="px-4 py-3 text-center font-semibold text-gray-900">${scaledTPS}</td>
                `;
                tableBody.appendChild(row);
            });
            if (executionMode === 'duration') updateDurationFields(totalScaledUsers);
        }

        function changeExecutionMode() {
            executionMode = document.getElementById('executionMode').value;
            document.getElementById('modeDescription').textContent = executionModes[executionMode].description;
            document.getElementById('durationControls').style.display = executionMode === 'duration' ? 'block' : 'none';
            document.getElementById('sanityConfig').style.display = executionMode === 'sanity' ? 'block' : 'none';
            document.getElementById('loopHeader').textContent = executionMode === 'duration' ? 'Loop (‚àû)' : 'Loops';
            renderTable();
            showToast(`Switched to ${executionMode} mode`, 'info');
        }

        function updateDurationFields(totalScaledUsers) {
            const steadyState = parseInt(globalVariables.steadyState) || 0;
            document.getElementById('durationHours').value = Math.floor(steadyState / 3600);
            document.getElementById('durationMinutes').value = Math.floor((steadyState % 3600) / 60);
            document.getElementById('durationSeconds').value = steadyState % 60;
            document.getElementById('totalDuration').textContent = steadyState + ' sec';
            const rampupSec = parseInt(globalVariables.rampup) || 0;
            const intervalSec = Math.max(1, Math.round(rampupSec / totalScaledUsers));
            document.getElementById('usersPerInterval').value = 1;
            document.getElementById('intervalSeconds').value = intervalSec;
            document.getElementById('totalUsersDisplay').textContent = totalScaledUsers;
            updateEstimatedRampup();
        }

        function updateEstimatedRampup() {
            const usersPerInterval = parseInt(document.getElementById('usersPerInterval').value) || 1;
            const intervalSeconds = parseInt(document.getElementById('intervalSeconds').value) || 1;
            const totalUsers = parseInt(document.getElementById('totalUsersDisplay').textContent) || 1;
            const rampupSeconds = Math.ceil(totalUsers / usersPerInterval) * intervalSeconds;
            globalVariables.rampup = rampupSeconds.toString();
            const hrs = Math.floor(rampupSeconds / 3600);
            const mins = Math.floor((rampupSeconds % 3600) / 60);
            const secs = rampupSeconds % 60;
            document.getElementById('estimatedRampup').textContent = `${hrs}h ${mins}m ${secs}s`;
        }

        function toggleStatus(index) {
            threadGroupData[index].status = !threadGroupData[index].status;
            threadGroupData[index].element.setAttribute("enabled", threadGroupData[index].status.toString());
            renderTable();
        }

        function updateThreadCount(index, value) {
            threadGroupData[index].count = parseInt(value, 10) || 1;
            renderTable();
        }

        function updateLoopCount(index, value) {
            threadGroupData[index].loops = value;
            renderTable();
        }

        function enableAllThreadGroups() {
            threadGroupData.forEach(tg => {
                tg.status = true;
                tg.element.setAttribute("enabled", "true");
            });
            renderTable();
            showToast('All enabled', 'success');
        }

        function disableAllThreadGroups() {
            threadGroupData.forEach(tg => {
                tg.status = false;
                tg.element.setAttribute("enabled", "false");
            });
            renderTable();
            showToast('All disabled', 'warning');
        }

        function applyMasterScale() {
            if (!jmxDocument) {
                showToast('Upload JMX first', 'error');
                return;
            }
            const percent = parseFloat(document.getElementById("masterScale").value);
            if (isNaN(percent) || percent <= 0) {
                showToast('Enter valid percentage', 'error');
                return;
            }
            const factor = percent / 100;
            threadGroupData.forEach(tg => {
                const scaledThreads = Math.max(1, Math.ceil(tg.count * factor));
                tg.count = scaledThreads;
                updateThreadCountInXML(tg.element, scaledThreads);
                if (tg.throughput > 0) {
                    tg.throughput = tg.throughput * factor;
                    const tgHashTree = tg.element.nextElementSibling;
                    if (tgHashTree && tgHashTree.tagName === "hashTree") {
                        updateThroughputInHashTree(tgHashTree, factor);
                    }
                }
            });
            renderTable();
            showToast(`Applied ${percent}% scaling`, 'success');
        }

        function updateThreadCountInXML(tgElement, count) {
            let updated = false;
            const intProps = tgElement.getElementsByTagName("intProp");
            for (let i = 0; i < intProps.length; i++) {
                if (intProps[i].getAttribute("name") === "ThreadGroup.num_threads") {
                    intProps[i].textContent = count.toString();
                    updated = true;
                    break;
                }
            }
            if (!updated) {
                const stringProps = tgElement.getElementsByTagName("stringProp");
                for (let i = 0; i < stringProps.length; i++) {
                    if (stringProps[i].getAttribute("name") === "ThreadGroup.num_threads") {
                        stringProps[i].textContent = count.toString();
                        updated = true;
                        break;
                    }
                }
            }
            if (!updated) {
                const sp = jmxDocument.createElement("stringProp");
                sp.setAttribute("name", "ThreadGroup.num_threads");
                sp.textContent = count.toString();
                tgElement.appendChild(sp);
            }
        }

        function updateThroughputInHashTree(hashTree, multiplier) {
            for (let child of hashTree.children) {
                if (child.tagName === "PreciseThroughputTimer") {
                    const doubleProps = child.getElementsByTagName("doubleProp");
                    for (let dp of doubleProps) {
                        if (dp.getAttribute("name") === "throughput") {
                            const current = parseFloat(dp.textContent.trim());
                            if (!isNaN(current)) dp.textContent = (current * multiplier).toString();
                        } else {
                            const nameEl = dp.getElementsByTagName("name")[0];
                            const valEl = dp.getElementsByTagName("value")[0];
                            if (nameEl && nameEl.textContent === "throughput" && valEl) {
                                const current = parseFloat(valEl.textContent.trim());
                                if (!isNaN(current)) valEl.textContent = (current * multiplier).toString();
                            }
                        }
                    }
                }
                if (child.tagName === "hashTree") updateThroughputInHashTree(child, multiplier);
            }
        }

        function updateVariablesTab() {
            document.getElementById('rampupValue').textContent = globalVariables.rampup + ' sec';
            document.getElementById('rampupHours').textContent = secondsToHours(globalVariables.rampup);
            document.getElementById('steadyStateValue').textContent = globalVariables.steadyState + ' sec';
            document.getElementById('steadyStateHours').textContent = secondsToHours(globalVariables.steadyState);
        }

        function secondsToHours(seconds) {
            if (seconds === "N/A" || seconds === "") return "N/A";
            const sec = parseFloat(seconds);
            if (isNaN(sec)) return "N/A";
            return `${(sec / 3600).toFixed(2)} hours`;
        }

        function downloadJMX() {
            if (!jmxDocument) {
                showToast('No JMX loaded', 'error');
                return;
            }
            try {
                threadGroupData.forEach(tg => {
                    let finalCount = tg.count, finalLoops = tg.loops, finalRampup = null;
                    if (executionMode === 'sanity') {
                        finalCount = 1;
                        finalLoops = document.getElementById('sanityIterations').value || '5';
                        finalRampup = document.getElementById('sanityRampup').value || '1';
                    } else if (executionMode === 'duration') {
                        finalLoops = '-1';
                    }
                    tg.element.setAttribute("enabled", tg.status.toString());
                    updateThreadCountInXML(tg.element, finalCount);
                    updateLoopCountInXML(tg.element, finalLoops);
                    if (executionMode === 'sanity') {
                        updateRampupInXML(tg.element, finalRampup);
                        disablePreciseThroughputTimer(tg.element);
                    }
                });
                if (executionMode === 'duration') updateGlobalVariables();
                const serializer = new XMLSerializer();
                let xmlString = serializer.serializeToString(jmxDocument);
                if (!xmlString.startsWith('<?xml')) {
                    xmlString = '<?xml version="1.0" encoding="UTF-8"?>\n' + xmlString;
                }
                const blob = new Blob([xmlString], { type: 'application/xml' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'modified_test_plan.jmx';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                showToast('JMX downloaded!', 'success');
            } catch (error) {
                showToast('Download failed: ' + error.message, 'error');
            }
        }

        function updateRampupInXML(tgElement, rampupValue) {
            let updated = false;
            const stringProps = tgElement.getElementsByTagName("stringProp");
            for (let i = 0; i < stringProps.length; i++) {
                if (stringProps[i].getAttribute("name") === "ThreadGroup.ramp_time") {
                    stringProps[i].textContent = rampupValue;
                    updated = true;
                    break;
                }
            }
            if (!updated) {
                const intProps = tgElement.getElementsByTagName("intProp");
                for (let i = 0; i < intProps.length; i++) {
                    if (intProps[i].getAttribute("name") === "ThreadGroup.ramp_time") {
                        intProps[i].textContent = rampupValue;
                        updated = true;
                        break;
                    }
                }
            }
            if (!updated) {
                const sp = jmxDocument.createElement("stringProp");
                sp.setAttribute("name", "ThreadGroup.ramp_time");
                sp.textContent = rampupValue;
                tgElement.appendChild(sp);
            }
        }

        function updateLoopCountInXML(tgElement, loops) {
            const loopController = tgElement.querySelector('elementProp[name="ThreadGroup.main_controller"]');
            if (loopController) {
                const loopsProps = loopController.getElementsByTagName('stringProp');
                for (let j = 0; j < loopsProps.length; j++) {
                    if (loopsProps[j].getAttribute('name') === 'LoopController.loops') {
                        loopsProps[j].textContent = loops;
                        return;
                    }
                }
                const loopsIntProps = loopController.getElementsByTagName('intProp');
                for (let j = 0; j < loopsIntProps.length; j++) {
                    if (loopsIntProps[j].getAttribute('name') === 'LoopController.loops') {
                        loopsIntProps[j].textContent = loops;
                        return;
                    }
                }
            }
        }

        function disablePreciseThroughputTimer(threadGroup) {
            const tgHashTree = threadGroup.nextElementSibling;
            if (tgHashTree && tgHashTree.tagName === "hashTree") {
                const timers = tgHashTree.getElementsByTagName("PreciseThroughputTimer");
                for (let timer of timers) timer.setAttribute("enabled", "false");
            }
        }

        function updateGlobalVariables() {
            const argumentsList = jmxDocument.getElementsByTagName("Arguments");
            for (let i = 0; i < argumentsList.length; i++) {
                const arg = argumentsList[i];
                if (arg.getAttribute("testname") === "rampupSteadyDuration") {
                    const elements = arg.getElementsByTagName("elementProp");
                    for (let j = 0; j < elements.length; j++) {
                        const nameNode = elements[j].getElementsByTagName("stringProp")[0];
                        const valueNode = elements[j].getElementsByTagName("stringProp")[1];
                        if (nameNode && valueNode) {
                            if (nameNode.textContent === "rampup") valueNode.textContent = globalVariables.rampup;
                            if (nameNode.textContent === "steadyState") {
                                const hours = parseInt(document.getElementById('durationHours').value) || 0;
                                const minutes = parseInt(document.getElementById('durationMinutes').value) || 0;
                                const seconds = parseInt(document.getElementById('durationSeconds').value) || 0;
                                valueNode.textContent = ((hours * 3600) + (minutes * 60) + seconds).toString();
                            }
                        }
                    }
                }
            }
        }

        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            toastMessage.textContent = message;
            toast.className = "fixed bottom-4 right-4 text-white px-6 py-3 rounded-lg shadow-lg transform transition-transform duration-300";
            if (type === 'success') toast.className += ' bg-green-600';
            else if (type === 'error') toast.className += ' bg-red-600';
            else if (type === 'warning') toast.className += ' bg-yellow-600';
            else toast.className += ' bg-black';
            toast.style.transform = 'translateY(0)';
            toast.style.opacity = '1';
            setTimeout(() => {
                toast.style.transform = 'translateY(5rem)';
                toast.style.opacity = '0';
            }, 3000);
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        document.addEventListener('DOMContentLoaded', function() {
            ['usersPerInterval', 'intervalSeconds'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('change', updateEstimatedRampup);
            });
            ['durationHours', 'durationMinutes', 'durationSeconds'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('change', function() {
                    const hours = parseInt(document.getElementById('durationHours').value) || 0;
                    const minutes = parseInt(document.getElementById('durationMinutes').value) || 0;
                    const seconds = parseInt(document.getElementById('durationSeconds').value) || 0;
                    document.getElementById('totalDuration').textContent = ((hours * 3600) + (minutes * 60) + seconds) + ' sec';
                });
            });
            ['sanityRampup', 'sanityIterations'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('change', renderTable);
            });
        });
    </script>
</body>
</html>
